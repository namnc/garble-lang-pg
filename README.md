# Garble Language

Garble is a simple programming language for [Secure Multi-Party Computation](https://en.wikipedia.org/wiki/Secure_multi-party_computation) with [Garbled Circuits](https://en.wikipedia.org/wiki/Garbled_circuit). The circuits generated by Garble specify a _function_, with each input coming from a different party and the output computed collaboratively by all parties in a way that no party learns another party's input. Garble is statically typed, low-level, purely functional and uses a syntax heavily inspired by Rust.

All programs written in Garble are deliberately Turing-incomplete (only supporting bounded recursion), guaranteeing that they can be compiled to circuits using only `AND`, `XOR` and `NOT` gates (without any kind of stateful latches or registers). Here's an example of solving the [Millionaire's Problem](https://en.wikipedia.org/wiki/Yao%27s_Millionaires%27_problem) in Garble:

```rust
// A function for solving Yao's Millionaire's problem:

enum Richest {
    IsA,
    IsB,
    Tie,
}

fn main(a: u64, b: u64) -> Richest {
    if a > b {
        Richest::IsA
    } else if b > a {
        Richest::IsB
    } else {
        Richest::Tie
    }
}
```

For more examples, see the [Language Tour](language_tour.md).

## How to Use Garble

The circuits generated by Garble are meant to be executed using a cryptographically secure MPC engine, which is not provided by this crate. Garble is agnostic about the details of the MPC engine and assumes only that the engine executes Garbled Circuits with support for `AND`, `XOR` and `NOT` gates. For local development and testing, Garble supports a direct and unencrypted evaluation of a generated circuit, with all inputs supplied by the local user.

To execute the Millionaire's problem example, first install the `garble` utility, then run the function:

```sh
$ cargo install --git https://github.com/sine-fdn/garble
$ garble garble_examples/millionaires.garble.rs 10000000 10000
Richest::IsA
$ garble garble_examples/millionaires.garble.rs 100 5000000
Richest::IsB
$ garble garble_examples/millionaires.garble.rs 1000 1000
Richest::Tie
```

## Architecture of this Repository

The Garble compiler is relatively straightforward and turns a program `&str` into a `circuit::Circuit` (or aborts with a scan/parse/type error). The different steps and their modules are as follows (with steps 1-4 happening during compile time, step 5 during run time):

  1. `scan.rs` splits a program `&str` into a sequence of `token::Token`s.
  2. `parse.rs` parses a sequence of `token::Token`s into an untyped `ast::Program`.
  3. `check.rs` type-checks an untyped `ast::Program`, returning a `typed_ast::Program`.
  4. `compile.rs` converts a well-typed `typed_ast::Program` into a `circuit::Circuit`.
  5. `eval.rs` executes a `circuit::Circuit` with locally supplied inputs.

## Rough Edges

Garble is still in a very early stage. The core language is usable, but the user experience leaves a lot to be desired. Some of the current pain points are:

  - No panics / errors / handling of overflows, divide-by-zero or out-of-bounds array access. These are all undefined behavior and will simply return garbage data.
  - Lots of type casts necessary for unsigned and signed integers. Type coercion is currently very basic, it is often necessary to cast or to use typed literals (e.g. `1u32`).
  - Poor coverage of edge cases in the parser, some valid expressions cannot be parsed.
  - Pattern exhaustiveness check, but no detailed exhaustiveness reporting.
  - No first-class functions / lambdas / closures.
  - Only basic error reporting.
  - No optimizations.
  - No structs.
